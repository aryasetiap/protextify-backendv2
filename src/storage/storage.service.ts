import {
  Injectable,
  Logger,
  NotFoundException,
  BadRequestException,
  InternalServerErrorException,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from '../prisma/prisma.service';
import { RealtimeGateway } from '../realtime/realtime.gateway';
import * as fs from 'fs/promises';
import * as path from 'path';
import PDFDocument from 'pdfkit';
import * as DOCX from 'docx';
import { nanoid } from 'nanoid';

export interface GeneratedFileResult {
  filename: string;
  url: string;
  size: number;
  format: 'pdf' | 'docx';
}

@Injectable()
export class StorageService {
  private readonly logger = new Logger(StorageService.name);
  private readonly uploadPath: string;
  private readonly baseUrl: string;

  constructor(
    private readonly configService: ConfigService,
    private readonly prismaService: PrismaService,
    private readonly realtimeGateway: RealtimeGateway,
  ) {
    // Setup storage directory path
    this.uploadPath = path.join(process.cwd(), 'uploads', 'submissions');
    this.baseUrl =
      this.configService.get<string>('BASE_URL') || 'http://localhost:3000';

    // Ensure upload directory exists
    this.ensureUploadDirectory();
  }

  private async ensureUploadDirectory(): Promise<void> {
    try {
      await fs.mkdir(this.uploadPath, { recursive: true });
      this.logger.log(`Storage directory ensured: ${this.uploadPath}`);
    } catch (error) {
      this.logger.error('Failed to create upload directory:', error);
    }
  }

  /**
   * Generate PDF file from submission content
   */
  async generatePDF(
    submissionId: string,
    userId: string,
    role: string,
  ): Promise<GeneratedFileResult> {
    this.logger.log(`[STORAGE] Generating PDF for submission: ${submissionId}`);

    // Get submission data
    const submission = await this.getSubmissionWithPermissions(
      submissionId,
      userId,
      role,
    );

    return new Promise((resolve, reject) => {
      try {
        const filename = `submission-${submissionId}-${nanoid(8)}.pdf`;
        const filePath = path.join(this.uploadPath, filename);
        const doc = new PDFDocument();
        const stream = require('fs').createWriteStream(filePath);

        doc.pipe(stream);

        // Header
        doc.fontSize(20).text('Submission Report', 50, 50);
        doc.moveDown();

        // Submission Info
        doc.fontSize(14).text('Submission Details', 50, doc.y + 20);
        doc
          .fontSize(12)
          .text(`Student: ${submission.student.fullName}`, 50, doc.y + 20)
          .text(`Assignment: ${submission.assignment.title}`, 50, doc.y + 15)
          .text(`Class: ${submission.assignment.class.name}`, 50, doc.y + 15)
          .text(`Status: ${submission.status}`, 50, doc.y + 15)
          .text(
            `Last Updated: ${submission.updatedAt.toLocaleString()}`,
            50,
            doc.y + 15,
          );

        if (submission.grade !== null) {
          doc.text(`Grade: ${submission.grade}`, 50, doc.y + 15);
        }

        doc.moveDown();

        // Plagiarism info (if available and user has permission)
        if (
          submission.plagiarismChecks &&
          submission.plagiarismChecks.status === 'completed'
        ) {
          doc.fontSize(14).text('Plagiarism Check Results', 50, doc.y + 20);
          doc
            .fontSize(12)
            .text(
              `Plagiarism Score: ${submission.plagiarismChecks.score}%`,
              50,
              doc.y + 20,
            )
            .text(
              `Word Count: ${submission.plagiarismChecks.wordCount}`,
              50,
              doc.y + 15,
            )
            .text(
              `Checked At: ${submission.plagiarismChecks.checkedAt.toLocaleString()}`,
              50,
              doc.y + 15,
            );

          doc.moveDown();
        }

        // Content
        doc.fontSize(14).text('Submission Content', 50, doc.y + 20);
        doc.fontSize(11).text(submission.content, 50, doc.y + 15, {
          width: 500,
          align: 'justify',
        });

        // Footer
        doc
          .fontSize(8)
          .text('Generated by Protextify Platform', 50, doc.page.height - 50)
          .text(
            `Generated at: ${new Date().toLocaleString()}`,
            50,
            doc.page.height - 35,
          );

        doc.end();

        stream.on('finish', async () => {
          try {
            const stats = await fs.stat(filePath);
            const result: GeneratedFileResult = {
              filename,
              // ðŸ”§ Fix: Update URL with correct path
              url: `${this.baseUrl}/api/storage/download/${filename}`,
              size: stats.size,
              format: 'pdf',
            };

            this.logger.log(
              `[STORAGE] PDF generated successfully: ${filename}`,
            );
            this.logger.log(`[STORAGE] PDF URL: ${result.url}`);

            // Send notification
            await this.sendDownloadNotification(
              userId,
              role,
              'pdf',
              result.url,
              submission,
            );

            resolve(result);
          } catch (error) {
            this.logger.error('PDF finish handler error:', error);
            reject(error);
          }
        });

        stream.on('error', (error) => {
          this.logger.error('PDF generation stream error:', error);
          reject(error);
        });
      } catch (error) {
        this.logger.error('PDF generation failed:', error);
        reject(error);
      }
    });
  }

  /**
   * Generate DOCX file from submission content
   */
  async generateDOCX(
    submissionId: string,
    userId: string,
    role: string,
  ): Promise<GeneratedFileResult> {
    this.logger.log(
      `[STORAGE] Generating DOCX for submission: ${submissionId}`,
    );

    // Get submission data
    const submission = await this.getSubmissionWithPermissions(
      submissionId,
      userId,
      role,
    );

    try {
      const filename = `submission-${submissionId}-${nanoid(8)}.docx`;
      const filePath = path.join(this.uploadPath, filename);

      // Create DOCX document
      const doc = new DOCX.Document({
        sections: [
          {
            properties: {},
            children: [
              // Title
              new DOCX.Paragraph({
                text: 'Submission Report',
                heading: DOCX.HeadingLevel.TITLE,
              }),

              // Submission details
              new DOCX.Paragraph({
                text: 'Submission Details',
                heading: DOCX.HeadingLevel.HEADING_1,
              }),
              new DOCX.Paragraph({
                text: `Student: ${submission.student.fullName}`,
              }),
              new DOCX.Paragraph({
                text: `Assignment: ${submission.assignment.title}`,
              }),
              new DOCX.Paragraph({
                text: `Class: ${submission.assignment.class.name}`,
              }),
              new DOCX.Paragraph({ text: `Status: ${submission.status}` }),
              new DOCX.Paragraph({
                text: `Last Updated: ${submission.updatedAt.toLocaleString()}`,
              }),

              ...(submission.grade !== null
                ? [new DOCX.Paragraph({ text: `Grade: ${submission.grade}` })]
                : []),

              // Plagiarism results (if available)
              ...(submission.plagiarismChecks &&
              submission.plagiarismChecks.status === 'completed'
                ? [
                    new DOCX.Paragraph({
                      text: 'Plagiarism Check Results',
                      heading: DOCX.HeadingLevel.HEADING_1,
                    }),
                    new DOCX.Paragraph({
                      text: `Plagiarism Score: ${submission.plagiarismChecks.score}%`,
                    }),
                    new DOCX.Paragraph({
                      text: `Word Count: ${submission.plagiarismChecks.wordCount}`,
                    }),
                    new DOCX.Paragraph({
                      text: `Checked At: ${submission.plagiarismChecks.checkedAt.toLocaleString()}`,
                    }),
                  ]
                : []),

              // Content
              new DOCX.Paragraph({
                text: 'Submission Content',
                heading: DOCX.HeadingLevel.HEADING_1,
              }),
              new DOCX.Paragraph({ text: submission.content }),

              // Footer
              new DOCX.Paragraph({ text: '' }), // Space
              new DOCX.Paragraph({
                text: `Generated by Protextify Platform at ${new Date().toLocaleString()}`,
                style: 'footer',
              }),
            ],
          },
        ],
      });

      // Save file
      const buffer = await DOCX.Packer.toBuffer(doc);
      await fs.writeFile(filePath, buffer);

      const stats = await fs.stat(filePath);
      const result: GeneratedFileResult = {
        filename,
        // ðŸ”§ Fix: Update URL with correct path
        url: `${this.baseUrl}/api/storage/download/${filename}`,
        size: stats.size,
        format: 'docx',
      };

      this.logger.log(`[STORAGE] DOCX generated successfully: ${filename}`);
      this.logger.log(`[STORAGE] DOCX URL: ${result.url}`);

      // Send notification
      await this.sendDownloadNotification(
        userId,
        role,
        'docx',
        result.url,
        submission,
      );

      return result;
    } catch (error) {
      this.logger.error('DOCX generation failed:', error);
      throw new InternalServerErrorException('Failed to generate DOCX file');
    }
  }

  /**
   * Get file for download (serve static file)
   */
  async downloadFile(
    filename: string,
  ): Promise<{ filePath: string; mimeType: string }> {
    const filePath = path.join(this.uploadPath, filename);

    try {
      await fs.access(filePath);

      const ext = path.extname(filename).toLowerCase();
      const mimeType =
        ext === '.pdf'
          ? 'application/pdf'
          : ext === '.docx'
            ? 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
            : 'application/octet-stream';

      this.logger.log(`[STORAGE] File found: ${filename}, path: ${filePath}`);
      return { filePath, mimeType };
    } catch (error) {
      this.logger.error(
        `[STORAGE] File not found: ${filename}, path: ${filePath}`,
      );
      throw new NotFoundException('File not found');
    }
  }

  /**
   * Clean up old files (run periodically)
   */
  async cleanupOldFiles(maxAgeHours: number = 24): Promise<number> {
    try {
      const files = await fs.readdir(this.uploadPath);
      const now = Date.now();
      let deletedCount = 0;

      for (const filename of files) {
        const filePath = path.join(this.uploadPath, filename);
        const stats = await fs.stat(filePath);

        const ageHours = (now - stats.mtime.getTime()) / (1000 * 60 * 60);

        if (ageHours > maxAgeHours) {
          await fs.unlink(filePath);
          deletedCount++;
          this.logger.log(`[STORAGE] Deleted old file: ${filename}`);
        }
      }

      this.logger.log(
        `[STORAGE] Cleanup completed, deleted ${deletedCount} files`,
      );
      return deletedCount;
    } catch (error) {
      this.logger.error('File cleanup failed:', error);
      return 0;
    }
  }

  /**
   * Get submission with permission validation
   */
  private async getSubmissionWithPermissions(
    submissionId: string,
    userId: string,
    role: string,
  ) {
    const submission = await this.prismaService.submission.findUnique({
      where: { id: submissionId },
      include: {
        student: true,
        assignment: {
          include: { class: true },
        },
        plagiarismChecks: true,
      },
    });

    if (!submission) {
      throw new NotFoundException('Submission not found');
    }

    // Check permissions
    const isStudent = role === 'STUDENT' && submission.studentId === userId;
    const isInstructor =
      role === 'INSTRUCTOR' &&
      submission.assignment.class.instructorId === userId;

    if (!isStudent && !isInstructor) {
      throw new BadRequestException('No access to this submission');
    }

    return submission;
  }

  /**
   * Send download notification via WebSocket
   */
  private async sendDownloadNotification(
    userId: string,
    role: string,
    format: string,
    downloadUrl: string,
    submission: any,
  ): Promise<void> {
    try {
      this.realtimeGateway.sendNotification(userId, {
        type: 'file_ready',
        message: `Your ${format.toUpperCase()} file is ready for download!`,
        data: {
          submissionId: submission.id,
          format,
          downloadUrl,
          filename: path.basename(downloadUrl),
        },
        createdAt: new Date().toISOString(),
      });

      this.logger.log(
        `[STORAGE] Download notification sent to user: ${userId}`,
      );
    } catch (error) {
      this.logger.error('Failed to send download notification:', error);
    }
  }
}
